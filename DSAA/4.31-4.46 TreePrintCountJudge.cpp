#include <iostream>
#include <random>
#include <ctime>
#include <array>
#include <cmath>
#include <deque>
using namespace std;
struct Node
{
	Node() :Data(0), LChild(nullptr), RChild(nullptr) {};
	Node(double D, Node *pl, Node *pr) :Data(D), LChild(pl),RChild(pr){};
	double Data;
	int Height;
	Node *LChild,*RChild;
};

//Generators: Objects that generate uniformly distributed numbers.
//Distributions : Objects that transform sequences of numbers generated by a generator into 
//sequences of numbers that follow a specific random variable distribution, such as uniform, Normal or Binomial.
int RandInt(const int Low, const int Upper)
{
	default_random_engine generator(time(nullptr)%3600);
	uniform_int_distribution<int> distribution(Low, Upper);
	return distribution(generator); 
}



//4.31
int NodesNum(Node *T)
{
	if (T == nullptr)
		return 0;
	else
		return 1+NodesNum(T->LChild) + NodesNum(T->RChild);
}
int LeavesNum(Node *T)
{
	if (T == nullptr)
		return 0;
	else if (T->LChild==nullptr && T->RChild == nullptr)
		return 1;
	else return LeavesNum(T->LChild) + LeavesNum(T->RChild);
}
int FullNodesNum(Node *T)
{
	if (T->LChild == nullptr || T->RChild == nullptr)
		return 0;
	else return 1 + FullNodesNum(T->LChild) + FullNodesNum(T->RChild);
}

//4.32
struct Rslt
{
	bool IsOrdered;
	double MIN, MAX;
};
Rslt TestBST(Node *T)
{

	if (T->LChild == nullptr && T->RChild == nullptr)
		return{ 1,T->Data,T->Data };
	if (T->LChild == nullptr && T->RChild != nullptr)
		return{ T->Data <= T->RChild->Data,T->Data,T->RChild->Data };
	if (T->LChild != nullptr && T->RChild == nullptr)
		return{ T->Data >= T->LChild->Data,T->LChild->Data,T->Data };
	Rslt LRslt = TestBST(T->LChild);
	Rslt RRslt = TestBST(T->RChild);
	return{ LRslt.IsOrdered && RRslt.IsOrdered && (T->Data >= LRslt.MAX) && \
		(T->Data <= RRslt.MIN), LRslt.MIN, RRslt.MAX };
		
}
bool IsBST(Node *T)
{
	return TestBST(T).IsOrdered;
}

//4.33
void RmovLeaves(Node *&T)
{
	if (T == nullptr || (T->LChild == nullptr &&  T->RChild == nullptr))
	{
		T = nullptr; return;
	}
	RmovLeaves(T->LChild);
	RmovLeaves(T->RChild);
}

//4.34
Node *GenerateRandomBST(const int Low, const int Upper)
{
	Node *Root = nullptr;
	if (Low <= Upper)
	{
		int RootInt = RandInt(Low, Upper);
		Root = new Node(RootInt, GenerateRandomBST(Low, RootInt - 1), \
			GenerateRandomBST(RootInt + 1, Upper));
	}
	return Root;
}

//4.35
Node *GenerateLeastAVLTree(int Height)
{
	Node *Root;
	if (Height < 0)
		Root = NULL;
	else
	{
		Root = new Node;
		Root->Height = Height;
		Root->Data = Height;
		Root->LChild = GenerateLeastAVLTree(Height - 1);
		Root->RChild = GenerateLeastAVLTree(Height - 2);
	}
	return Root;
}

//4.36
Node *GenerateHalfDivid(const int Low, const int Upper)
{
	Node *Root = nullptr;
	if (Low <= Upper)
	{
		int RootInt = (Low + Upper) / 2;
		Root = new Node(RootInt, GenerateHalfDivid(Low, RootInt - 1), \
			GenerateHalfDivid(RootInt + 1, Upper));
	}
	return Root;
}
Node *GenerateFullBST(int Height)
{
	int NodesNum = pow(2,Height+1)-1;
	return GenerateHalfDivid(1, NodesNum);
}

//4.37
void PrintRange(Node *T, double Low, double Upper)
{
	if (T != nullptr)
	{
		if (T->Data < Low)
			PrintRange(T->RChild, Low, Upper);
		else if(T->Data > Upper)
			PrintRange(T->LChild, Low, Upper);
		else
		{
			cout << T->Data << " ";
			PrintRange(T->LChild, Low, T->Data);
			PrintRange(T->RChild, T->Data, Upper);
		}

	}
}

//4.40
void PrintInLevel(Node *T)
{
	
	deque<Node*> Dque;
	Dque.push_back(T);
	while (Dque.size() != 0)
	{
		Node *PT = Dque.front();
		if (PT->LChild != nullptr)
			Dque.push_back(PT->LChild);
		if (PT->RChild != nullptr)
			Dque.push_back(PT->RChild);
		cout << PT->Data<<" ";
		Dque.pop_front();
	}
}
//
void PrintPre(Node *T)
{
	if (T != nullptr)
	{
		cout << T->Data << " ";
		PrintPre(T->LChild);
		PrintPre(T->RChild);
	}
}

//4.45
bool IsSimilar(Node *T1, Node *T2)
{
	if (T1 == nullptr || T2 == nullptr)
		return T1 == nullptr && T2 == nullptr;
	else return IsSimilar(T1->LChild, T2->LChild) && IsSimilar(T1->RChild, T2->RChild);
}

//4.46
bool IsIsomorphic(Node *T1, Node *T2)
{
	if (T1 == nullptr || T2 == nullptr)
		return T1 == nullptr && T2 == nullptr;
	else return (IsIsomorphic(T1->LChild, T1->LChild) && IsIsomorphic(T1->RChild, T2->RChild)) || \
		(IsIsomorphic(T1->LChild, T2->RChild) && IsIsomorphic(T1->RChild, T2->LChild));
}


int main()
{
	Node *BST = GenerateRandomBST(1, 100);
	Node *AVL = GenerateLeastAVLTree(10);
	Node *FullBST = GenerateFullBST(1);
	//cout << NodesNum(BST) << " " << NodesNum(AVL) << endl;
	//cout << FullNodesNum(BST) << " " << FullNodesNum(AVL) << endl;
	//cout << LeavesNum(BST) << " " << LeavesNum(AVL) << endl;
	//PrintRange(FullBST, 25, 75); cout << endl;
	//cout << IsBST(BST) << endl << IsBST(AVL) << endl;;
	
	/*PrintInLevel(FullBST);
	PrintTree(FullBST); cout << endl;
	cout << NodesNum(FullBST) << " " << LeavesNum(FullBST) << endl;
	RmovLeaves(FullBST);
	PrintTree(FullBST); cout << endl;
	cout << NodesNum(FullBST) << " " << LeavesNum(FullBST) << endl;*/

	/*Node *AVL2 = GenerateLeastAVLTree(10);
	cout << IsSimilar(AVL, AVL2) <<endl;
	cout << IsSimilar(AVL, FullBST) << endl;*/


	return 0;
}